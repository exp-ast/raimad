"""
Class for base component
"""

from typing import Any, Type, Self, List
from dataclasses import dataclass, field
import inspect
import logging

import PyCIF as pc

# Possibilities:
# None can be used when parent and child have identical layers
# OR when both have only one layer
# str can be used to specify the layername of the parent
# when child has only one layer
# otherwise needs full dict
SubcomponentLayermapShorthand = None | str | dict
SubpolygonLayermapShorthand = None | str

def update_options(Options: dict, base: type):
    new_options = {}

    for name, opt in Options.items():

        if name in base.Options.keys():
            if opt is not pc.Option.Shadow:
                assert False, "Redefining option."
            new_options[name] = base.Options[name].get_shadow()
            continue

        if isinstance(opt, pc.Option):
            new_options[name] = opt
            continue

        new_options[name] = pc.Option(*opt)
        print("Using tuple as option")

    return new_options


def update_layers(Layers: dict, base: type):
    new_layers = {}

    for i, (name, layer) in enumerate(Layers.items()):

        if name in base.Layers.keys():
            assert False, "redefining layer"

        if isinstance(layer, pc.Layer):
            layer.index = i
            new_layers[name] = layer
            continue

        new_layers[name] = pc.Layer(*layer, index=i)
        print("Using tuple as layer")

    # TODO layer indices currently unused.
    # TODO what is this function, interfaces should not override layers

    return new_layers


class ComponentMeta(type):
    def __new__(cls, name, bases, namespace):

        #if len(bases) == 0:
        #    base = Component

        #elif len(bases) == 1:
        #    base = bases[0]
        #    assert issubclass(bases, Component)
        #    if base is Component:
        #        print("Redundant")  # TODO clean up warnings/exceptions here.

        #else:
        #    assert False

        assert '_make' in namespace.keys()

        component_bases = [
            base for base in bases
            if isinstance(type(base), cls)
            ]

        # TODO consider replacing with __init_subclass__ ???

        match len(component_bases):
            case 0:
                # This is the Component class
                pass

            case 1:
                # Interface
                namespace['Options'] = update_options(
                    namespace['Options'],
                    component_bases[0],
                    )
                assert 'Layers' not in namespace.keys()
                #namespace['Layers'] = update_layers(
                #    namespace['Layers'],
                #    component_bases[0],
                #    )

            case _:
                raise Exception(
                    "Multiple inheritance unspported for components"
                    )

        new_component = super().__new__(cls, name, bases, namespace)
        return new_component


class Component(pc.Markable, metaclass=ComponentMeta):
    """
    Class for base component
    """
    Options = pc.Dict()  # TODO safe putting mutable here??
    Layers = pc.Dict()
    Modulebrowser_howtoget = None
    # Something like 'from pc_Mymodule.Mycompo import Mycompo',
    # otherwise this is autogenerated using inspect.

    def __init__(self, opts=None, transform=None):
        """
        args and kwargs are interpreted the same way as Dotdict,
        so can be used to set parameters during creation.
        """
        super().__init__()
        self.subcomponents = []
        self.subpolygons = []

        self._set_opts(opts or {})

        self._make(self.opts)

    def _set_opts(self, opts: dict):
        """
        Apply new options,
        """
        unexpected_opts = set(opts.keys()) - set(self.Options.keys())
        if unexpected_opts:
            raise Exception(
                f"Component {self} received "
                f"Unexpected options: {unexpected_opts}"
                )
        self.opts = pc.Dict({
            name: optspec.default
            for name, optspec
            in self.Options.items()
            })
        self.opts.update(opts)

    def add_subcomponent(
            self,
            component,
            layermap_shorthand: SubcomponentLayermapShorthand = None,
            ):
        """
        Add new component as a subcomponent.
        """
        layermap = parse_subcomponent_layermap_shorthand(
            self.Layers.keys(),
            component.Layers.keys(),
            layermap_shorthand,
            )

        subcomponent = Subcomponent(
            component,
            layermap,
            )

        # TODO update bbox here?

        self.subcomponents.append(subcomponent)

    def add_subpolygon(
            self,
            polygon,
            layermap: SubpolygonLayermapShorthand = None,
            ):
        """
        Layermap map subcomponent layers to component layers
        """
        layermap_full = parse_subpolygon_layermap_shorthand(
            self.Layers.keys(),
            layermap
            )

        subpolygon = Subpolygon(
            polygon,
            layermap_full,
            )

        #self._bbox.add_xyarray(polygon.get_xyarray())

        self.subpolygons.append(subpolygon)

    def add_subpolygons(
            self,
            polys: List[pc.Polygon | pc.PolygonGroup] | pc.Polygon | pc.PolygonGroup,
            layermap: SubpolygonLayermapShorthand = None,
            ):
        """
        Add multiple subpolygons or subpolygon groups.
        """
        if isinstance(polys, pc.Polygon):
            self.add_subpolygon(polys, layermap)

        elif isinstance(polys, pc.PolygonGroup):
            for polygon in polys.get_polygons():
                self.add_subpolygon(polygon, layermap)

        elif isinstance(polys, list | tuple | set):
            # TODO isiterable
            for poly in polys:
                self.add_subpolygons(poly, layermap)

        else:
            raise Exception("Please only pass polygons or polygongroups")

    def get_polygons(self, include_layers=None):
        """
        This should descend into subcomponents and subpolygons recursively,
        applying layermaps and transformations as it goes,
        to get a list of raw polygons in the end.

        returns dict mapping layers to polygons
        layers are same as self.layers

        include_layers is to specify which layers
        are needed, None means all.
        """

        if include_layers is None:
            include_layers = self.Layers.keys()
        else:
            assert set(include_layers).issubset(self.Layers.keys())

        layers = {layer: [] for layer in include_layers}

        for subcomponent in self.subcomponents:
            for layer, polygons in subcomponent.get_polygons(include_layers).items():
                for polygon in polygons:
                    polygon.apply_transform(self.transform)
                    layers[layer].append(polygon)

        for subpolygon in self.subpolygons:
            polygon = subpolygon.get_polygon(include_layers)
            if not polygon:
                continue
            polygon.apply_transform(self.transform)
            layers[subpolygon.layermap].append(polygon)

        return layers

    #def __str__(self):
    #    #return (
    #    #    f'Component {type(self).__name__} '
    #    #    f'with {str(self.transform)}'
    #    #    )

    def _make(self, opts=None):
        """
        This method should actually generate all subpolygons
        and subcomponents.

        This is an abstract base class,
        so here this method actually does nothing.

        opts allows to pass a custom options list

        Note that make() should work with all default parameters.
        This will actually be used for making the preview image.
        """

    @classmethod
    def parent(cls):
        """
        Return parent class.
        This is a shorthand for cls.__bases__[0]
        """
        return cls.__bases__[0]

    @classmethod
    def is_interface(cls):
        if cls is Component:
            print("""Base Component class is not an interface.""")
            return False

        return (cls.parent() is Component)

    @classmethod
    def is_interface_of(cls, of: Type[Self]):
        if cls is Component:
            print("""Base Component class is not an interface.""")
            return False

        if of is Component:
            print("""Base Component class cannot have interfaces""")
            return False

        return issubclass(cls, of)

    @classmethod
    def get_custom_methods(cls):
        """
        Extract custom methods from this component class.
        For example, automatic connection methods
        from CPWs.
        """
        # TODO can interfaces override or pass through
        # custom methods? How would this work?

        # Maybe we need a special decorator
        # for external methods?

        return {
            attr_name: attr
            for attr_name, attr
            in cls.__dict__.items()
            if not attr_name.startswith('_') and inspect.isfunction(attr)
            }


class Subcomponent(object):
    """
    Container for component that is part of another component.
    """
    def __init__(self, component, layermap):
        self.component = component
        self.layermap = layermap

    def get_polygons(self, include_layers):
        """
        This is the counterpart to component.get_polygons()
        that applies the correct transformations and

        So basically it's a constant flip-flop between component.get_polygons()
        and subcomponent.get_polygons(), in a sort of tree,
        with the leaves being subpolygons
        """
        # Which layers (of the child) need to be included?
        include_layers_child = [
            child_layer
            for child_layer, parent_layer in self.layermap.items()
            if parent_layer is not None
            ]

        # Get a dict mapping child layer names to lists of polys
        child_layers = self.component.get_polygons(include_layers_child)

        # Create a dict mapping *parent* layer names to lists of polys
        parent_layers = {
            self.layermap[child_layer_name]: polys
            for child_layer_name, polys in child_layers.items()
            }

        return parent_layers


class Subpolygon(object):
    def __init__(self, polygon, layermap):
        self.polygon = polygon
        self.layermap = layermap
        # ^ this is called a layermap, but
        # really it's just a single string
        # specifying which layer in the parent component
        # will this polygon go to.

    def get_polygon(self, include_layers):
        """
        """
        if self.layermap not in include_layers:
            return None

        # Here, the polygon is copied for export.
        # This means that any transforms that are applied
        # during export (i.e. to flatten the coordinate hierarchy)
        # don't affect the actual polygon,
        # so that the component can be used later on.
        return self.polygon.copy()


def parse_subcomponent_layermap_shorthand(parent_layers, child_layers, layermap_shorthand: SubcomponentLayermapShorthand):
    if layermap_shorthand is None:
        if len(parent_layers) == len(child_layers):
            # Case One: parent and child the same number of layers
            layermap = dict(zip(child_layers, parent_layers))

        elif set(child_layers).issubset(set(parent_layers)):
            layermap = dict(zip(child_layers, child_layers))

        #elif len(child_layers) == len(parent_layers) == 1:
        #    # Case Two: parent and child both have one layer
        #    # (not necessarily same name)
        #    layermap = {list(child_layers)[0]: list(parent_layers)[0]}
        #    # (the list() cast is in here just in case someone passes
        #    # something like a dict_keys object into this function
        else:
            raise Exception(
                "Could not parse None layermap shoarthand"
                )
    elif isinstance(layermap_shorthand, str):
        if len(child_layers) != 1:
            raise Exception(
                "You specified an str layermap shorthand, "
                "but the child component doesn't have "
                "just one layer."
                )

        if layermap_shorthand not in parent_layers:
            raise Exception(
                "You specified an str layermap shorthand, "
                "but that layer is not in the parent component."
                )

        layermap = {list(child_layers)[0]: layermap_shorthand}

    elif isinstance(layermap_shorthand, dict):
        if not set(layermap_shorthand.keys()).issubset(child_layers):
            raise Exception(
                "Layermap keys are not a subset of child component layers"
                )

        if not set(layermap_shorthand.values()).issubset(parent_layers):
            raise Exception(
                "Layermap values are not a subset of parent component layers"
                )

        layermap = layermap_shorthand

    else:
        raise Exception(
            "Layermap shorthand is incorrect type"
            )

    # Pad layermap
    for missing_layer in set(child_layers) - set(layermap):
        layermap[missing_layer] = None

    return layermap


def parse_subpolygon_layermap_shorthand(parent_layers, layermap_shorthand: SubpolygonLayermapShorthand):
    if layermap_shorthand is None:
        if len(parent_layers) == 1:
            return list(parent_layers)[0]
        else:
            raise Exception(
                "You specified a None layermap shorthand, "
                "but the parent component has more than one layer"
                )

    elif isinstance(layermap_shorthand, str):
        if layermap_shorthand in parent_layers:
            return layermap_shorthand
        else:
            raise Exception(
                "There is no such layer in parent component."
                )

    else:
        raise Exception(
            "Layermap shorthand is incorrect type"
            )



